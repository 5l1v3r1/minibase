#!/bin/sh

unset arch cross target cc ar strip tp lto

commanddir=/sbin
servicedir=/sbin/service
networkdir=/sbin/network
systemdir=/sbin/system

man1dir=/sman/man1
man5dir=/sman/man5
man8dir=/sman/man8

cflags=-Os

die() { echo "$@" >&2; exit 1; }

while [ $# -gt 0 ]; do
	case "$1" in
		*dir=*) eval "$1" ;;
		cross=*) eval "$1"; cross="${cross}-" ;;
		target=*) eval "$1"; cross="${cross:-$target-}" ;;
		arch=*) eval "$1" ;;
		cc=*) eval "$1" ;;
		ar=*) eval "$1" ;;
		strip=*) eval "$1" ;;
		clang) clang=yes ;;
		devel) cflags="-Wall -g -DDEVEL" ;;
		debug) cflags="-Os -g" ;;
		wextra) cflags="$cflags -Wextra" ;;
		werror) cflags="$cflags -Werror" ;;
		lto) lto="-flto " ;;
		only) shift; only="$@"; break ;;
		*) die "Unexpected argument $1" ;;
	esac; shift
done

test -z "$ar" && ar="${cross}ar"
test -z "$strip" && strip="${cross}strip"

if [ -n "$clang" -a -z "$cc" ]; then
	cc="clang${target:+ --target=$target}"
elif [ -z "$cc" ]; then
	cc="${cross}gcc"
fi

if [ -z "$arch" ]; then
	mach=`$cc -dumpmachine`
	arch=${mach%%-*}
	case "$arch" in
		aarch64) arch=arm64 ;;
		riscv64) arch=riscv ;;
		riscv32) die "RV32 is not supported" ;;
		mips64el)  arch=mips64 ;;
		mipsn32)   arch=mips32 ;;
		mipsn32el) arch=mips32 ;;
		mipsel)    arch=mips ;;
	esac
	test -n "$arch" || die "Cannot determine target arch"
	test -d "lib/arch/$arch" || die "Unsupported arch $arch"
fi

cat > config.mk <<END
ARCH = $arch

CC = \$/mini-cc
AR = $ar
LD = \$(CC)
AS = \$(CC)
STRIP = $strip

commanddir = $commanddir
servicedir = $servicedir
networkdir = $networkdir
systemdir = $systemdir

man1dir = $man1dir
man5dir = $man5dir
man8dir = $man8dir
END

if [ -n "$only" ]; then
cat >> config.mk <<END

only = $only
END
fi

cat > mini-cc <<END
#!/bin/sh

case "\$0" in
	*/*) base=\${0%/*} ;;
	*) echo "\$0 may not be called from PATH" >&2; exit 1 ;;
esac

needslib=yes

for _ in "\$@"; do
	case "\$_" in
		-c|-E|-S) unset needslib ;;
	esac
done

END

# GCC may be configured to produce PIEs without explicit -pie options,
# and it would do so even if given -ffreestanding -static. This is not
# acceptable for minibase, so the code below tries to force non-PIE mode.
#
# Current gcc versions also generate GOT relocations no matter what.
# No idea how to disable them atm. It's mostly harmless, but adds one
# dirty page for executables that would not need it otherwise.
#
# clang does it right and produces nice static executables with no GOT.

if [ -n "$clang" ]; then
cat >> mini-cc <<END
exec $cc -ffreestanding \\
        -fno-asynchronous-unwind-tables -fno-stack-protector -fno-vectorize \\
	-static -nopie -fno-pic -fno-plt $lto \\
	-nostdinc -I\$base/lib/arch/$arch -I\$base/lib -MD \\
	-Wno-unused-command-line-argument -Wno-gnu \\
	$cflags "\$@" \\
	-nostdlib \${needslib:+\$base/lib/all.a}
END
else
cat >> mini-cc <<END
exec $cc -ffreestanding \\
	-fno-asynchronous-unwind-tables -fno-stack-protector \\
	-static -fno-pie -fno-PIE -fno-pic -fno-PIC $lto \\
	-nostdinc -I\$base/lib/arch/$arch -I\$base/lib -MD \\
	$cflags "\$@" \\
	-nostdlib -Wl,-\\( \${needslib:+\$base/lib/all.a -lgcc} -Wl,-\\)
END
fi

chmod a+x mini-cc
