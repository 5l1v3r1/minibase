What is this?
~~~~~~~~~~~~~
This project contains a set of tools intended for early boot environment
(initrd, initcpio and possibly later stages for small systems).
The tools are small, statically linked and need no libc.

The project is highly experimental and (at this point) incomplete.
Some crucial tools are still to be written before building a viable
initcpio becomes possible. Use at your own risk.


Who may want to use it
~~~~~~~~~~~~~~~~~~~~~~
First and foremost people who would like to avoid libc dependency
for whatever reason. This may be useful for initcpio, but also for
weird cases like messing with binary-only router firmware when
linking against its internal libc is undesirable or impossible.

Another idea is getting as far as possible with the boot process
on static tools only, which may lead to a self-contained and very
fast "base system".

Finally, it is easy to trace and audit these tools down to syscall
level, both for security and for educational (how it works?) purposes.


How is it different from busybox?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Busybox aims to provide common POSIX tools in a package with the
smallest total size, or something close to that. It is not very
well suited for providing individual tools, only the whole package.

Busybox typically stays in the memory after being loaded (cached)
once, saving memory and time for repeated usage.

This project aims to provide small individual tools, so that they
could be combined freely and picked one at a time.

These tools are meant to be used rarely, perhaps only once during
boot, then unloaded immediately.


Compatibility
~~~~~~~~~~~~~
None. The tools follow Linux syscalls closely instead of trying
to be compatible with common GNU or busybox implementations.


Hybrid setups
~~~~~~~~~~~~~
Because the tools are standalone and independent, they can be used
together with e.g. busybox, providing rarely-used, system-specific
functions and leaving POSIX stuff to busybox.


Licensing
~~~~~~~~~
GPL version 2 or any later, see COPYING.


Credits
~~~~~~~
A lot of code here actually comes from busybox, which in turn
pulls from util-linux and coreutils, with numerous modifications
along the way.

Syscall code (static inline functions with asm volatile blocks)
follows musl. Because they got it right.

The Rust coreutils project provided a great deal of inspiration,
specifically by showing how not to write coreutils.


See also
~~~~~~~~
https://busybox.net/
http://www.landley.net/toybox/
http://suckless.org (ubase and sbase)
https://swtch.com/plan9port/

https://www.gnu.org/software/coreutils/coreutils.html
https://www.kernel.org/pub/linux/utils/util-linux/
https://github.com/uutils/coreutils
