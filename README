About the project
~~~~~~~~~~~~~~~~~
The code here builds into what is generally known as "early userspace",
or sometimes an "init system". A loose set of userspace tools meant to
bring the system up and keep it running.

Making a Linux system capable of booting and starting something useful
(like a user interface for instance) requires either

  * kernel, glibc, sysvinit, bash, coreutils, kmod, mount, loginutils, ...
  * or kernel, glibc, dbus, systemd, kmod, ...
  * or kernel, musl and busybox
  * or kernel and minibase

along with the useful parts and their dependencies.

This is a simplification and the list is incomplete, but it should
give the right idea of what minibase is.

The listed components form the base of the system. Their role is roughly
initialization, configuration and general support for the useful parts.
What exactly does that entail differs wildly between projects; minibase
can be thought of as being in-between busybox and systemd. The primary
target for this project is a personal computer (a desktop or a laptop)
running a GUI.

minibase is written in raw syscalls using a small custom C library.
The resulting executables are always statically linked and have no
external dependencies other than the kernel itself.


Project status
~~~~~~~~~~~~~~
The project is ONGOING but not yet complete or even stable.
Components currently included in the package:

  * batch command runner / script interpreter (msh)
  * early-stage boot utils (switchroot, modprobe, mount).
  * non-encrypted block device locator (findblk).
  * encrypted device locator and passphrase prompt (passblk).
  * support tooling for disk encryption (dektool, dmcrypt).
  - no fsck for any file system yet.

  * process supervision suite (init, super, reboot, svctl).

  * udev event monitor (udevmod).
  * syslogd and related tools.
  * non-privileged mount service (mountd, pmount).
  * controlled privilege escalation service (suhub, sudo)

  * VT/DRI/input multiplexer (vtmux) aka that part of logind
    everyone keeps asking about.
  * simple non-graphical greeter (ctrlvt).

  * networking interface manager and DHCP client (ifmon)
  * Wi-Fi (WPA2-PSK) supplicant and connection manager (wsupp).
  * manual interface setup tools (ip4cfg, ip4info) [incomplete].
  - no sntpd yet.

  * simple interactive shell (cmd).
  * basic command line tools (cat, ls, du, df etc).
  * small linux-specific tools (systime, sync, dmesg etc).

  - no package manager / download tool yet.
  - no audio tools of any kind.

With everything in place, the system should boot on kernel and minibase alone
to the point where it can run X or Wayland GUI, connect to network and start
downloading packages.


Compiler and libc
~~~~~~~~~~~~~~~~~
To build minibase, get any gcc toolchain targeting the right CPU.
The compiler will be used with -nostdinc -nostdlib so it doesn't
matter which libc (if any) it was configured with.
Clang can be used as well.

Supported targets: x86_64 arm aarch64 rv64 mips mips64 i386.
Anything else won't work even if toolchain is available.


Quick start
~~~~~~~~~~~
Bootable images for QEMU (buildroot, minibase, Xorg, Weston) along
with the build scripts are maintained in a dedicated repository:

    https://github.com/arsv/minibase-br/

Get the latest sys-plain or sys-crypt from Releases, check included
instructions. Inspect the build scripts, rootfs and initrd contents
to understand how the system boots. Check doc/boot.txt here as well.

Start reading the sources at temp/compat, src/cmdops, src/init.


How to build and run the tools
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For a proper build, run

    ./configure
    make
    make install     # default DESTDIR is ./out

To try the tools without setting up a VM, configure and build
the project in development mode:

    make clean
    ./configure devel
    make

Most tools can run right from their source directories.


Feature highlights
~~~~~~~~~~~~~~~~~~
Some features in no particular order.

Minibase comes with a proper service supervisor. (This is really
only worth mentioning because of inevitable attempts to compare
it to OpenRC).

Init process is staged, similar to s6 and runit but unlike SysV, systemd
and most other systems. The supervisor is unitary (same parent for all
child processes), similar to SysV and systemd but unlike s6, runit and
other daemontools derivatives.

There is no fstab in minibase, and no conventional mount(1).
The tools that handle mounts are written with hot-plugging in mind.

Minibase comes with a functional replacement for logind that is not
a fork or a clone of systemd-logind, and does not need dbus to work.

There are no conventional logins in minibase and no user passwords.
The passphrase entered during boot is used to unwrap disk encryption
keys. The system is assumed to run on a personal computing device
owned by its only human user.

Sessions are normally pre-configured and pinned to certain VTs.
Switching to a VT starts the session assigned to that particular VT.

Minibase does not use dbus, or any other system bus for that matter.
IPC is done point-to-point over unix sockets using simple netlink-
based protocol.

Minibase is meant to be run with suid bits disabled. Any privilege
escalation in a minibase system (including the sudo command) happens
via IPC to privileged services.


Just how small exactly?
~~~~~~~~~~~~~~~~~~~~~~~
The largest individual executable so far is `wsupp`, the WPA supplicant.
Statically linked for x86_64, it's about 27 KiB in size. Realistically
it also needs `ifmon` (20 KiB) to work, and the client tool `wifi` (12 KiB).

`msh` is about 16 KiB. `cmd` (interactive shell) is about 18 KiB.
`super` (pid 1 for the majority of system's uptime) is about 10 KiB.
`vtmux` (logind equivalent) is about 12 KiB.

Why bother making it small? Because it's a side effect of making it readable.
The idea is that anyone could pick a tool from minibase, start reading it
and gain complete understanding of how it works in a very reasonable amount
of time, say hours. And if necessary, audit or debug it down to assembly level.
A major point in achieving this is making sure there are no unnecessary
wrappers, useless abstractions or dead code, which in turn shows in the size
of the resulting executables.


Contributing
~~~~~~~~~~~~
Do not send patches for minibase itself. Doing so will likely only slow
the project down. If there's a bug to be fixed, or a tool that you think
should be in minibase, open an issue. The ability to scrap and re-design
certain tools unimpeded is way too important for the project at this
stage.

Not every tool is worth including in mini-BASE. Just like in any other
case, it is perfectly ok to have dedicated repos and dedicated packages
for some tools, especially if different developers are involved.

The best way to actually contribute to the project is to write something
that would fit well alongside minibase in a running system. For the most
projects, whatever it may be it likely won't even be tied to minibase
and would work just well in runit or s6 or even systemd based installation.

Area of particular interest: lightweight GUI desktop components.
Something to run atop of X or Wayland once minibase gets you there.
This includes both the primary desktop and things like a nice GUI greeter
to replace `ctrlvt` which is really only a stub.


Licensing
~~~~~~~~~
GNU Public License version 3, see COPYING.
Limited closed-box license may or may not get added in the future.

The code in lib/sys, lib/bits and lib/arch constitutes the public interface
of the Linux kernel. No claims are made for that code, and it should not be
copyrightable anyway. If unsure, grab corresponding fragments from either
the kernel sources (GPLv2) or the musl libc (MIT license).

The code in lib/crypto is mostly BSD-licensed. See README there.


Credits
~~~~~~~
Dietlibc and "Writing Small and Fast Software" by Felix von Leitner.
https://www.fefe.de/dietlibc/diet.pdf

The project was heavily influenced by busybox at early stages.
Certain decision from skarnet/s6 project also played significant role.
Syscall code (static inline functions with asm volatile blocks)
follows musl, because musl folks got it right.

The Rust coreutils project provided great deal of inspiration,
specifically by showing how not to write coreutils.


See also
~~~~~~~~
https://busybox.net/
http://www.landley.net/toybox/
http://www.fefe.de/embutils/
http://skarnet.org/software/
http://suckless.org
http://jdebp.eu/Softwares/nosh/
http://b0llix.net/perp/
http://u-root.tk/
https://swtch.com/plan9port/

https://www.gnu.org/software/coreutils/coreutils.html
https://www.kernel.org/pub/linux/utils/util-linux/
https://github.com/uutils/coreutils

https://github.com/mit-pdos/xv6-public (userspace tools)
