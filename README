What is this?
~~~~~~~~~~~~~
minibase is a set of small userspace tools for Linux intended to
boot the system and provide a lightweight but reliable foundation
to build the rest of the system on.

The tools are written in raw syscalls, statically linked, and have
no external dependencies, not even libc. They are easy to build,
and once built can be used on any cpu-compatible Linux system.


What's inside / Current status
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The project is highly experimental and (at this point) incomplete.
Some tools are missing, and some tools still need work.

  * Simple non-interactive shell (msh) for scripting the boot
    process and service startup.
  
  * Early-stage boot utils (switchroot, kmod, mount, waitfor).
  * Small basic unix tools (ls, du, df, cat, kill etc)
  * Several small linux-specific tools (systime, fstrim, dmesg etc)
  
  * Process supervisor suite aka init (init, scv, scvmon, reboot),
    split stage implementation similar to daemontools or runit.
  
  - No udevd yet.
  - No unprivileged mount daemon yet.
  - No controlled privilege escalation daemon (sud/sudo) yet.

  * DHCP client (dhcp) and manual interface setup tools (ip4cfg, ip4info).
  - No sntpd yet.

  * Wi-Fi scanner and connection manager (wimon), also capable
    of handling wired interfaces.
  * Minimalistic wpa supplicant (wpa);
    WPA2-PSK only, CCMP/CCMP or CCMP/TKIP.

  - No package manager yet.
  - No http download tool yet.

  * VT/DRM/input multiplexer (vtmux) aka that part of systemd-logind
    everyone keeps asking about.

  - No vtmux-compatible getty or greeters yet.

  - No interactive shell yet.

With everything in place, the system should be able to boot, on minibase
alone, up to the point where it's ready to download, install and start GUI.


How is it different from busybox?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Busybox aims to provide common POSIX tools in a package with the
smallest total size, or something close to that. It is not very
well suited for providing individual tools, only the whole package.

Busybox typically stays in the memory after being loaded (cached)
once, saving memory and time for repeated usage.

Minibase aims to provide small *individual* tools, so that they
could be combined freely, picked one at a time, and discarded
once no longer needed. The scope of the tools provided by minibase
is also quite different.


How is it different from common (GNU) tools?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In a lot of ways really, but here's an easy trick that highlights
the fundamental distinction well. Strace some simple tool from
a common Linux distro:

	strace echo Hello, world

then repeat with the same tool from this package:

	strace ./echo Hello, world

For best effect, make sure you're using GNU tools linked dynamically
against GNU libc, though even busybox linked against musl produces
rather impressive traces.


Compatibility
~~~~~~~~~~~~~
The tools are *NOT* meant to be POSIX-, GNU-, or anything else compatible.
Instead the goal is to provide comparable functionality by simplier means.


Licensing
~~~~~~~~~
GNU Public License version 3, see COPYING.

Note that due to the nature of the tools, most of the common GPL gripes
do not apply to this package. You should not be linking against them
or extending them anyhow. However, non-tivoization clause is still there.

Limited closed-box use is allowed on different terms, see COPYING.alt.

The code in lib/sys, lib/bits and lib/arch constitutes the public interface
of the Linux kernel. No claims are made for that code, and it should not be
copyrightable anyway. If unsure, grab corresponding fragments from either
the kernel sources (GPLv2) or the musl libc (MIT).

The code from lib/crypto is in public domain. See README there.


Credits
~~~~~~~
The whole project was inspired and initially heavily influenced by busybox.
Certain decision from skarnet/s6 project also played significant role.

Syscall code (static inline functions with asm volatile blocks)
follows musl, because they got it right.

The Rust coreutils project provided a great deal of inspiration,
specifically by showing how not to write coreutils.


See also
~~~~~~~~
https://busybox.net/
http://www.landley.net/toybox/
http://www.fefe.de/embutils/
http://skarnet.org/software/ (portable-utils, linux-utils)
http://suckless.org (ubase and sbase)
http://jdebp.eu/Softwares/nosh/
https://swtch.com/plan9port/

https://www.gnu.org/software/coreutils/coreutils.html
https://www.kernel.org/pub/linux/utils/util-linux/
https://github.com/uutils/coreutils

https://github.com/mit-pdos/xv6-public (userspace tools)
