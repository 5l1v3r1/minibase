General notes
~~~~~~~~~~~~~
A "service" is a process that does not normally exit.

Traditionally, these are known as "daemons". However, while in practice
the same entities become either "services" or "daemons" depending on how
their startup is set up (i.e. on the init system), the strict definition
of "daemon" implies double-forking which services are expected not to do.

A service can be thought of as a daemon that did not fork during startup.
Which means its pid remains valid, and the parent can wait for it.

Here the focus is mostly on the system services, that is, services started
during system startup and expected to stay alive for the whole time the
system remains running. Within this project, system services get spawned
by svhub, all at once, right after the sequential startup phase ends.


Startup scripts
~~~~~~~~~~~~~~~
Each service started by svhub needs a file, /etc/svhub/$name, which
svhub will exec in a newly-created process. In most cases, it should be
a script exec'ing into the binary executable. Typical contents:

    #!/sbin/msh

    setenv FOO bar

    setgid system
    setuid blah

    exec /path/to/binary

The script gets spawned with the credentials of svhub itself, that is,
as root and with full capabilities. In most cases, it is up to the script
to drop unnecessary privileges. The choice of interpreter is free, svhub
does not care. Anything sys_execve() can load it should be fine.

It is important to make sure the script either execs into, or at least waits
for the service itself. For svhub, the process it spawned *is* the service.
That process will be monitored for abnormal exits, and will be sent signals
to during system shutdown.

The $name of the script identifies the service for control purposes (svctl).


Output capture and logging
~~~~~~~~~~~~~~~~~~~~~~~~~~
Services are not supposed to output anything to stdout or stderr during
normal opertion. For abnormal cases, svhub captures their output into a
short ring buffer which the user can inspect using `svctl show`.

Services may use syslog (or some other similar service) for logging events
during normal operation. This is completely unrelated them being supervised
by svctl.

There is no explicit support for redirecting stdout/stderr into syslog in
this project, and doing so is discouraged.


Dependencies
~~~~~~~~~~~~
System services are expected to have no explicit dependencies, other than
the system being out of the sequential initialization stage (rootfs mounted,
kernel state set up and so on).

Explicit dependencies on devices or IPC points being available indicate
incorrectly written code (often a race condition or invalid assumptions).
Alternatively, the service in question may just not be fit to be a system
services, and should be started on demand in response to some events.

# TODO: on-demand service supervisor, not in the project right now

There are some borderline cases where dependencies exists but can be worked
around by introducing timing constraints:

    #!/sbin/msh

    ...

    waitfor /dev/something

    exec /path/to/binary

In this example, svhub will spawn the script as usual, but waitfor will pause
the process while it's still a script.
