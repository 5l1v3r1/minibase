Strictly *uni-directional* unreliable system message bus.

The idea is to allow the services to announce state changes for anyone
listening. State query and service control must still be done over whatever
interface the service uses normally, unlike in bi-directional buses (dbus etc).

Put another way, simplified machine-local syslog with built-in tail -f.
Put yet another way, broadcast signals with minimal plaintext payload.


Usage scenario for UI panel network status applet.

The daemon starts first, binds two sockets in /run:

	shouts = socket(PF_LOCAL)
	bind(shouts, "/run/shoutd")
	listen(shouts)

	echoes = socket(PF_LOCAL)
	bind(echoes, "/run/echoes");
	listen(echoes)

	# poll over [ shouts, echoes ]

The applet listens for shouts:

	fd = socket(PF_LOCAL)
	connect(fd, "/run/echoes")
	# this may be repeated if the daemon drops the connection

The daemon accepts client connection:

	while((fd = accept(echoes)))
		push listeners, fd

The service has something to announce:

	sendto(PF_LOCAL, "/run/shoutd", "interface wlp1s0 is now up")
	# no error checks here
	# but this will likely need uid to be sent in anicillary payload.

The daemon receives the message, authenticates the sender and re-trasmits
it to anyone listening:

	while(msg = recvfrom(shouts))
		uid = get_sender_uid(msg)
		uname = uid_to_username(uid)
		foreach lfd (listeners)
			sendmsg(lfd, "$uname: $msg")

The applet receives the authenticated message:

	while(msg = recvmsg(fd))   # likely multiplexed via ppoll
		if msg =~ /^net:/
			query_network_status()
			update_display();

	# query_network_status should do some bi-directional communication
	# via some /run sockets, or maybe via netlink, or maybe run some
	# commands etc.

	# query_network_status may also be called spontaneously, with
	# no input from shoutd, for instance during startup, or on timer
	# event in some sort of polling mode.


Doing sender authentication relieves the listening clients from messing
with user credentials and allows them to do basically string matching,
while still providing protection against message forgery and low-key DoS.
It is assumed that the reaction to an expected message takes more time
that sending the message.

Either way, the listeners should not rely on the message payload too much.
Instead, the notifications are more like signals, notifying the listeners
that they may need to check something somewhere via different channels.
Proper access controls can then be implemented on those channels.

The total traffic on /run/echoes is assumed to be very low, so each listener
gets all the messages and is expected to sort them on its own. OTOH, maybe
some sort of limited daemon-controlled filtering (or subscription, from
client's POV) should be implemented, since a lot of them will likely only be
monitoring one or two "channels".
